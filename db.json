{
  "posts": [
    {
      "id": 1,
      "title": "C√≥mo construir una lista de tareas con React y JSON Server",
      "date": "2025-04-10",
      "author": "St√©fano E. Castro",
      "content": "### üöÄ Introducci√≥n al CRUD con React y JSON Server\n\nEste tutorial te guiar√° paso a paso para crear una aplicaci√≥n b√°sica de lista de tareas que implemente las cuatro operaciones fundamentales (CRUD): Crear, Leer, Actualizar y Eliminar. Usaremos **React** en el frontend, **JSON Server** para simular el backend RESTful, y la librer√≠a **Axios** para gestionar las peticiones HTTP.\n\n#### Paso 1: Configuraci√≥n del Proyecto y Axios\n\nPrimero, aseguramos que Axios est√© instalado. Luego, creamos una instancia base para simplificar futuras llamadas (como pide el deber):\n\n```javascript\n// src/api/client.js\nimport axios from 'axios';\n\nconst client = axios.create({\n  baseURL: 'http://localhost:3000',\n});\n\nexport default client;\n```\n\n#### Paso 2: Usando un Custom Hook (`useFetchData.js`)\n\nEn lugar de repetir la l√≥gica `useState` y `useEffect` en cada componente, creamos un *custom hook* que gestiona la carga de datos (la 'R' de CRUD), usando **Axios**:\n\n```javascript\n// src/hooks/useFetchData.js\nimport { useState, useEffect } from 'react';\nimport client from '../api/client';\n\nexport const useFetchData = (endpoint) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    client.get(endpoint)\n      .then(response => {\n        setData(response.data);\n        setLoading(false);\n      })\n      .catch(error => console.error('Error fetching:', error));\n  }, [endpoint]);\n  \n  return { data, loading };\n};\n```\n\n#### Paso 3: Implementando las Operaciones CRUD con Axios\n\n* **Leer (GET):** Ya cubierto por `useFetchData` (usado en `PostList.jsx` y `Home.jsx` si carga experiencia).\n* **Crear (POST):** Usamos `client.post('/posts', { title: 'Nueva tarea' })`.\n* **Eliminar (DELETE):** Usamos `client.delete(`/posts/${id}`)`.\n* **Actualizar (PUT/PATCH):** Usamos `client.patch(`/posts/${id}`, { completed: true })`.\n\n#### Paso 4: Integraci√≥n con React Router\n\nEl hook `useFetchData` y el `client.js` se importan en los componentes de la aplicaci√≥n. Por ejemplo, en el componente `TodoApp.jsx` se usar√≠a el hook, y las funciones de Crear/Eliminar se disparar√≠an por los botones del usuario. React Router se usa para navegar entre el listado (`/posts`) y el detalle (`/posts/:id`).\n\nEsta arquitectura asegura un c√≥digo limpio, modular y cumple con los requisitos de la API RESTful local."
    },
    {
      "id": 2,
      "title": "An√°lisis de la propuesta 'Temporal' en TC39",
      "date": "2025-04-12",
      "author": "St√©fano E. Castro",
      "content": "### üï∞Ô∏è La Necesidad de un API de Temporalidad Nativo\n\nHe escogido la propuesta **Temporal** de TC39, actualmente en Stage 3, que busca reemplazar los objetos `Date` nativos de JavaScript con un API moderno y robusto para manejar fechas y horas.\n\n#### ¬øQu√© problema resuelve?\n\nEl objeto `Date` actual en JavaScript es notoriamente deficiente. Solo soporta el UTC y la zona horaria local del sistema, es mutable (lo que lleva a errores), y no maneja correctamente escenarios complejos como husos horarios, calendarios no gregorianos o duraciones. La comunidad ha dependido de librer√≠as grandes como Moment.js o Day.js. Temporal busca estandarizar estas funcionalidades de forma nativa.\n\n#### ¬øC√≥mo funciona?\n\nTemporal introduce un conjunto de clases inmutables (no mutables, lo que es clave para la seguridad) que representan diferentes conceptos de tiempo:\n\n* **`Temporal.Instant`**: Un punto exacto en la l√≠nea de tiempo (como un timestamp).\n* **`Temporal.ZonedDateTime`**: Una fecha/hora con un huso horario espec√≠fico.\n* **`Temporal.PlainDate`**: Solo fecha, sin tiempo ni huso horario.\n* **`Temporal.Duration`**: Representa una cantidad de tiempo (ej., 5 horas y 30 minutos).\n\nEsto permite c√°lculos de tiempo mucho m√°s seguros y expresivos, como sumar o restar duraciones sin preocuparse por saltos de horario de verano.\n\n#### ¬øPor qu√© es relevante para el futuro de JavaScript?\n\nEsta propuesta es crucial. Al moverse a Stage 3, est√° muy cerca de ser implementada en todos los navegadores y entornos de ejecuci√≥n. Al fin, JavaScript tendr√° una herramienta nativa para el manejo de tiempo que se compara favorablemente con otros lenguajes (como Java o Python), lo que reducir√° la dependencia de librer√≠as de terceros y el tama√±o de los paquetes.\n\n#### Opini√≥n Cr√≠tica\n\nMe parece una propuesta **extremadamente √∫til**. La inmutabilidad de los objetos de tiempo es la caracter√≠stica m√°s importante, eliminando una fuente com√∫n de *bugs* en aplicaciones complejas. El riesgo principal es la curva de aprendizaje inicial, ya que la API es grande. Sin embargo, dada la complejidad del tiempo, este es un compromiso necesario para la robustez del lenguaje."
    }
  ],
  "experiencia": [
    {
      "id": 1,
      "position": "Desarrollador de Contenido Digital",
      "company": "ExP, Quito-Ecuador",
      "period": "Febrero 2024 - Presente",
      "description": "Dise√±o de contenido gr√°fico para generar impactos en posibles clientes del sector inmobiliario. Publicaci√≥n de multimedia para redes sociales y plataformas digitales."
    },
    {
      "id": 2,
      "position": "Servicio Comunitario",
      "company": "PUCE (Registros PUCA)",
      "period": "2024",
      "description": "Participaci√≥n en proyecto de servicio comunitario universitario."
    }
  ],
  "profile": {
    "name": "St√©fano Espinosa Castro",
    "title": "Desarrollador en Software",
    "email": "stefojc14sc06@hotmail.com",
    "phone": "+593 99 835 8412",
    "location": "Quito, Ecuador"
  }
}